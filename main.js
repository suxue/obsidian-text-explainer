const { Plugin, Modal, Setting, Notice, MarkdownView, PluginSettingTab } = require('obsidian');

const DEFAULT_NOTE_PROPERTIES = [
        { key: 'title', value: '{{selectedText}}' },
        { key: 'created', value: '{{date}}' },
        { key: 'source', value: '{{paragraphText}}' }
];

const DEFAULT_NOTE_BODY_TEMPLATE = `# {{selectedText}}

> Explanation generated on {{date}}

## Original Context
{{selectedText}}

## Explanation
{{content}}

---
*Generated by Text Explainer Plugin*`;

const NOTE_PLACEHOLDERS = [
        { token: '{{selectedText}}', description: 'Original selected text' },
        { token: '{{paragraphText}}', description: 'Paragraph containing the selection' },
        { token: '{{textBefore}}', description: 'Text that appears before the selection' },
        { token: '{{textAfter}}', description: 'Text that appears after the selection' },
        { token: '{{date}}', description: 'Current date in YYYY-MM-DD format' },
        { token: '{{content}}', description: 'Generated explanation as plain text' },
        { token: '{{contentHtml}}', description: 'Generated explanation with HTML formatting' }
];

// Default settings
const DEFAULT_SETTINGS = {
        model: "gpt-3.5-turbo",
        apiKey: "",
        baseUrl: "https://api.openai.com/v1",
        language: "Chinese",
        hotkeyModifiers: ["Alt"],
        hotkeyKey: "d",
        noteDirectory: "Explanations",
        noteProperties: DEFAULT_NOTE_PROPERTIES.map(prop => ({ ...prop })),
        noteBodyTemplate: DEFAULT_NOTE_BODY_TEMPLATE
};

// Main plugin class
class TextExplainerPlugin extends Plugin {
	async onload() {
		await this.loadSettings();

		// Add ribbon icon
		this.addRibbonIcon('message-circle', 'Text Explainer', () => {
			this.explainSelectedText();
		});

		// Add command (works in edit and reader mode)
		this.addCommand({
			id: 'explain-selected-text',
			name: 'Explain selected text',
			checkCallback: (checking) => {
				const selectionData = this.getSelectedText();
				if (selectionData && selectionData.selectedText) {
					if (!checking) this.explainSelectedText(selectionData.editor);
					return true;
				}
				return false;
			}
		});

		// Register hotkey (works in edit and reader mode)
		this.addCommand({
			id: 'explain-text-hotkey',
			name: 'Explain text (hotkey)',
			hotkeys: [{
				modifiers: this.settings.hotkeyModifiers,
				key: this.settings.hotkeyKey
			}],
			checkCallback: (checking) => {
				const selectionData = this.getSelectedText();
				if (selectionData && selectionData.selectedText) {
					if (!checking) this.explainSelectedText(selectionData.editor);
					return true;
				}
				return false;
			}
		});

		// Add settings tab
		this.addSettingTab(new TextExplainerSettingTab(this.app, this));

		console.log('Text Explainer plugin loaded');
	}

	onunload() {
		console.log('Text Explainer plugin unloaded');
	}

        async loadSettings() {
                const loadedData = await this.loadData();
                this.settings = Object.assign({}, DEFAULT_SETTINGS, loadedData);

                if (!Array.isArray(this.settings.noteProperties) || this.settings.noteProperties.length === 0) {
                        this.settings.noteProperties = DEFAULT_NOTE_PROPERTIES.map(prop => ({ ...prop }));
                } else {
                        this.settings.noteProperties = this.settings.noteProperties.map((prop) => ({
                                key: (prop && typeof prop.key === 'string') ? prop.key : '',
                                value: (prop && typeof prop.value === 'string') ? prop.value : ''
                        }));
                }

                if (!this.settings.noteBodyTemplate || typeof this.settings.noteBodyTemplate !== 'string') {
                        this.settings.noteBodyTemplate = DEFAULT_NOTE_BODY_TEMPLATE;
                }
        }

	async saveSettings() {
		await this.saveData(this.settings);
	}

	// Get selected text from the active editor or DOM selection
	getSelectedText(editor) {
		if (!editor) {
			const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
			if (activeView && activeView.editor) {
				editor = activeView.editor;
			}
		}

		// Try to get selection from editor (edit mode)
		if (editor) {
			const selection = editor.getSelection();
			if (selection) {
				// Get context around selection
				const cursor = editor.getCursor('from');
				const line = editor.getLine(cursor.line);
				const doc = editor.getValue();
				const selectionStart = editor.posToOffset(editor.getCursor('from'));
				const selectionEnd = editor.posToOffset(editor.getCursor('to'));

				// Get surrounding context
				const contextRange = 200;
				const textBefore = doc.substring(Math.max(0, selectionStart - contextRange), selectionStart).trim();
				const textAfter = doc.substring(selectionEnd, Math.min(doc.length, selectionEnd + contextRange)).trim();

				return {
					selectedText: selection,
					textBefore,
					textAfter,
					paragraphText: line,
					editor
				};
			}
		}

		// Try to get selection from DOM (reader mode)
		const selection = window.getSelection();
		if (selection && selection.toString().trim()) {
			const selectedText = selection.toString().trim();
			
			// Get context from surrounding DOM elements
			const range = selection.getRangeAt(0);
			const container = range.commonAncestorContainer;
			
			// Find the paragraph or container element
			let parentElement = container.nodeType === Node.TEXT_NODE ? container.parentElement : container;
			while (parentElement && !['P', 'DIV', 'LI', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6'].includes(parentElement.tagName)) {
				parentElement = parentElement.parentElement;
			}
			
			const paragraphText = parentElement ? parentElement.textContent.trim() : selectedText;
			
			// Get surrounding context by looking at siblings
			let textBefore = '';
			let textAfter = '';
			
			if (parentElement) {
				const fullText = parentElement.textContent;
				const selectedIndex = fullText.indexOf(selectedText);
				if (selectedIndex !== -1) {
					const contextRange = 200;
					textBefore = fullText.substring(Math.max(0, selectedIndex - contextRange), selectedIndex).trim();
					textAfter = fullText.substring(selectedIndex + selectedText.length, Math.min(fullText.length, selectedIndex + selectedText.length + contextRange)).trim();
				}
			}

			return {
				selectedText,
				textBefore,
				textAfter,
				paragraphText,
				editor: null // No editor in reader mode
			};
		}

		return null;
	}

	// Main function to explain selected text
	async explainSelectedText(editor) {
		const selectionData = this.getSelectedText(editor);
		
		if (!selectionData || !selectionData.selectedText) {
			new Notice('No text selected');
			return;
		}

		if (!this.settings.apiKey) {
			new Notice('Please configure your API key in settings');
			return;
		}

		// Create and show explanation modal
		const modal = new ExplanationModal(this.app, selectionData, this.settings, this);
		modal.open();
	}

	// Generate prompt based on text length and type
	getPrompt(selectedText, paragraphText, textBefore, textAfter) {
		const wordsCount = selectedText.split(' ').length;
		const systemPrompt = `Respond in ${this.settings.language} with HTML tags to improve readability.
- Prioritize clarity and conciseness
- Use bullet points when appropriate`;

		if (wordsCount >= 500) {
			return {
				prompt: `Create a structured summary in ${this.settings.language}:
- Identify key themes and concepts
- Extract 3-5 main points
- Use nested <ul> lists for hierarchy
- Keep bullets concise

for the following selected text:

${selectedText}
`,
				systemPrompt
			};
		}

		// For short text that looks like a sentence, offer translation
		if (wordsCount >= 5) {
			return {
				prompt: `Translate exactly to ${this.settings.language} without commentary:
- Preserve technical terms and names
- Maintain original punctuation
- Match formal/informal tone of source

for the following selected text:

${selectedText}
`,
				systemPrompt
			};
		}

		const pinYinExtraPrompt = this.settings.language === "Chinese" ? ' DO NOT add Pinyin for it.' : '';
		const ipaExtraPrompt = this.settings.language === "Chinese" ? '(with IPA if necessary)' : '';
		const asciiChars = selectedText.replace(/[\s\.,\-_'\"!?()]/g, '')
			.split('')
			.filter(char => char.charCodeAt(0) <= 127).length;
		const sampleSentenceLanguage = selectedText.length === asciiChars ? "English" : this.settings.language;

		// Context prompt
		const contextPrompt = textBefore || textAfter ?
			`# Context:
## Before selected text:
${textBefore || 'None'}
## Selected text:
${selectedText}
## After selected text:
${textAfter || 'None'}` : paragraphText;

		// Explain words prompt
		return {
			prompt: `Provide an explanation for the word: "${selectedText}${ipaExtraPrompt}" in ${this.settings.language} without commentary.${pinYinExtraPrompt}

Use the context from the surrounding paragraph to inform your explanation when relevant:

${contextPrompt}

# Consider these scenarios:

## Names
If "${selectedText}" is a person's name, company name, or organization name, provide a brief description (e.g., who they are or what they do).

## Technical Terms
If "${selectedText}" is a technical term or jargon
- give a concise definition and explain.
- Some best practice of using it
- Explain how it works. 
- No need example sentence for the technical term.

## Normal Words
- For any other word, explain its meaning and provide 1-2 example sentences with the word in ${sampleSentenceLanguage}.

# Format
- Output the words first, then the explanation, and then the example sentences if necessary.
- No extra explanation
- Remember to using proper html format like <p> <b> <i> <a> <li> <ol> <ul> to improve readability.
`,
			systemPrompt
		};
	}

	// Call LLM API
	async callLLM(prompt, systemPrompt, progressCallback) {
		if (!this.settings.apiKey) {
			throw new Error("Please set up your API key in the settings.");
		}

		const requestBody = {
			model: this.settings.model,
			messages: [
				{
					role: "system",
					content: systemPrompt
				},
				{
					role: "user",
					content: prompt
				}
			],
			temperature: 0.7,
			max_tokens: 2048
		};

		const response = await fetch(`${this.settings.baseUrl}/chat/completions`, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				'Authorization': `Bearer ${this.settings.apiKey}`
			},
			body: JSON.stringify(requestBody)
		});

		if (!response.ok) {
			const errorText = await response.text();
			throw new Error(`API request failed: ${response.status} ${response.statusText}. ${errorText}`);
		}

		const data = await response.json();
		
		if (!data.choices || !data.choices[0] || !data.choices[0].message) {
			throw new Error('No response received from the model');
		}

		const text = data.choices[0].message.content;
		
		// Call progress callback if provided
		if (progressCallback) {
			progressCallback(text, text);
		}

		return text;
	}
}

// Modal for displaying explanations
class ExplanationModal extends Modal {
        constructor(app, selectionData, settings, plugin) {
                super(app);
                this.selectionData = selectionData;
                this.settings = settings;
                this.plugin = plugin;
                this.noteProperties = (settings.noteProperties || DEFAULT_NOTE_PROPERTIES).map(prop => ({
                        key: (prop && typeof prop.key === 'string') ? prop.key : '',
                        value: (prop && typeof prop.value === 'string') ? prop.value : ''
                }));
                this.noteBodyTemplate = (typeof settings.noteBodyTemplate === 'string' && settings.noteBodyTemplate.trim().length > 0)
                        ? settings.noteBodyTemplate
                        : DEFAULT_NOTE_BODY_TEMPLATE;
                this.createNoteButton = null;
        }

        onOpen() {
                const { contentEl } = this;
                contentEl.addClass('text-explainer-modal');

                // Add title
		contentEl.createEl('h3', { text: 'Text Explanation' });

		// Show selected text
		const selectedDiv = contentEl.createDiv('selected-text');
		selectedDiv.createEl('strong', { text: 'Selected: ' });
		selectedDiv.createSpan({ text: this.selectionData.selectedText });

		// Loading indicator
		const loadingDiv = contentEl.createDiv('loading');
		loadingDiv.innerHTML = '<div class="loading-spinner"></div><span>Generating explanation...</span>';

		// Content area
		const contentDiv = contentEl.createDiv('explanation-content');
		contentDiv.style.display = 'none';

                // Error area
                const errorDiv = contentEl.createDiv('error-message');
                errorDiv.style.display = 'none';

                // Note configuration container
                this.noteConfigContainer = contentEl.createDiv('note-configuration');
                this.noteConfigContainer.style.display = 'none';
                this.renderNoteConfiguration();

                // Action buttons container
                const actionsDiv = contentEl.createDiv('explanation-actions');
                actionsDiv.style.display = 'none';

                // Create Note & Link button
                const createNoteBtn = actionsDiv.createEl('button', {
                        text: 'Create Note & Link',
                        cls: 'mod-cta'
                });
                createNoteBtn.addEventListener('click', () => this.createNoteAndLink());
                this.createNoteButton = createNoteBtn;

                // Start explanation process
                this.generateExplanation(loadingDiv, contentDiv, errorDiv, actionsDiv);
        }

        renderNoteConfiguration() {
                if (!this.noteConfigContainer) {
                        return;
                }

                this.noteConfigContainer.empty();

                this.noteConfigContainer.createEl('h4', { text: 'Configure generated note' });

                const placeholderInfo = this.noteConfigContainer.createDiv('placeholder-info');
                placeholderInfo.createSpan({ text: 'Available placeholders:' });
                const placeholderList = placeholderInfo.createEl('ul');
                NOTE_PLACEHOLDERS.forEach((placeholder) => {
                        const listItem = placeholderList.createEl('li');
                        listItem.createEl('code', { text: placeholder.token });
                        listItem.createSpan({ text: ` - ${placeholder.description}` });
                });

                const propertiesTable = this.noteConfigContainer.createEl('table', { cls: 'note-config-table' });
                const tableHead = propertiesTable.createEl('thead');
                const headRow = tableHead.createEl('tr');
                headRow.createEl('th', { text: 'Property' });
                headRow.createEl('th', { text: 'Value or placeholder' });
                headRow.createEl('th', { text: '' });

                const tableBody = propertiesTable.createEl('tbody');

                if (!this.noteProperties || this.noteProperties.length === 0) {
                        this.noteProperties = [{ key: '', value: '' }];
                }

                this.noteProperties.forEach((property, index) => {
                        const row = tableBody.createEl('tr');

                        const keyCell = row.createEl('td');
                        const keyInput = keyCell.createEl('input', {
                                attr: {
                                        type: 'text',
                                        value: property.key || '',
                                        placeholder: 'Property key'
                                }
                        });
                        keyInput.addEventListener('input', () => {
                                this.noteProperties[index].key = keyInput.value;
                        });

                        const valueCell = row.createEl('td');
                        const valueWrapper = valueCell.createDiv('value-input-wrapper');
                        const valueInput = valueWrapper.createEl('input', {
                                attr: {
                                        type: 'text',
                                        value: property.value || '',
                                        placeholder: 'Value or choose a placeholder'
                                }
                        });
                        valueInput.addEventListener('input', () => {
                                this.noteProperties[index].value = valueInput.value;
                        });

                        const placeholderSelect = valueWrapper.createEl('select', { cls: 'placeholder-select' });
                        placeholderSelect.createEl('option', { value: '', text: 'Insert placeholder...' });
                        NOTE_PLACEHOLDERS.forEach((placeholder) => {
                                const option = placeholderSelect.createEl('option', {
                                        value: placeholder.token,
                                        text: placeholder.token
                                });
                                option.setAttr('data-description', placeholder.description);
                                option.setAttr('title', placeholder.description);
                        });
                        placeholderSelect.addEventListener('change', (event) => {
                                const selectValue = event.target.value;
                                if (selectValue) {
                                        valueInput.value = selectValue;
                                        this.noteProperties[index].value = selectValue;
                                        event.target.value = '';
                                }
                        });

                        const removeCell = row.createEl('td', { cls: 'note-config-actions' });
                        const removeButton = removeCell.createEl('button', {
                                text: 'Remove',
                                cls: 'note-config-remove'
                        });
                        removeButton.addEventListener('click', (event) => {
                                event.preventDefault();
                                this.noteProperties.splice(index, 1);
                                this.renderNoteConfiguration();
                        });
                });

                const addRowButton = this.noteConfigContainer.createEl('button', {
                        text: 'Add property',
                        cls: 'note-config-add-row'
                });
                addRowButton.addEventListener('click', (event) => {
                        event.preventDefault();
                        this.noteProperties.push({ key: '', value: '' });
                        this.renderNoteConfiguration();
                });

                const templateSection = this.noteConfigContainer.createDiv('note-template-section');
                const templateLabel = templateSection.createEl('label', {
                        attr: { for: 'note-template-input' },
                        text: 'Note body template'
                });
                templateLabel.createSpan({ text: ' (include {{content}} where the explanation should appear)' });
                const templateTextarea = templateSection.createEl('textarea', {
                        cls: 'note-template-input',
                        attr: { id: 'note-template-input' }
                });
                templateTextarea.value = this.noteBodyTemplate || '';
                templateTextarea.addEventListener('input', () => {
                        this.noteBodyTemplate = templateTextarea.value;
                });
        }

	async generateExplanation(loadingDiv, contentDiv, errorDiv, actionsDiv) {
		try {
			const { prompt, systemPrompt } = this.plugin.getPrompt(
				this.selectionData.selectedText,
				this.selectionData.paragraphText,
				this.selectionData.textBefore,
				this.selectionData.textAfter
			);

			const response = await this.plugin.callLLM(prompt, systemPrompt, (textChunk, currentFullText) => {
				// Hide loading and show content on first chunk
				if (loadingDiv.style.display !== 'none') {
					loadingDiv.style.display = 'none';
					contentDiv.style.display = 'block';
				}
				
				// Update content
				this.updateContentDisplay(contentDiv, currentFullText || textChunk);
			});

                        // Final update
                        loadingDiv.style.display = 'none';
                        contentDiv.style.display = 'block';
                        actionsDiv.style.display = 'block';
                        this.updateContentDisplay(contentDiv, response);
                        this.explanationResponse = response;
                        this.explanationPlainText = this.extractPlainText(response);
                        if (this.noteConfigContainer) {
                                this.noteConfigContainer.style.display = 'block';
                        }

                } catch (error) {
                        console.error('Error generating explanation:', error);
                        loadingDiv.style.display = 'none';
                        errorDiv.style.display = 'block';
			errorDiv.innerHTML = `<strong>Error:</strong> ${error.message}`;
		}
	}

        updateContentDisplay(contentDiv, text) {
                if (!text) return;

                text = text.trim();
                if (text.length === 0) return;

		try {
			// Remove code block markers if present
			if (text.startsWith('```')) {
				if (text.endsWith('```')) {
					text = text.split('\n').slice(1, -1).join('\n');
				} else {
					text = text.split('\n').slice(1).join('\n');
				}
			}
			
			// If not HTML, wrap in paragraph
			if (!text.startsWith('<')) {
				text = `<p>${text.replace(/\n/g, '<br>')}</p>`;
			}
			
			contentDiv.innerHTML = text;
		} catch (e) {
                        console.error(`Error parsing content: ${e.message}`);
                        contentDiv.innerHTML = `<p>${text.replace(/\n/g, '<br>')}</p>`;
                }
        }

        extractPlainText(html) {
                if (!html) {
                        return '';
                }

                try {
                        if (typeof document !== 'undefined') {
                                const tempDiv = document.createElement('div');
                                tempDiv.innerHTML = html;
                                return (tempDiv.textContent || tempDiv.innerText || '').trim();
                        }
                } catch (error) {
                        console.warn('Fallback plain text conversion used:', error);
                }

                return html
                        .replace(/<[^>]*>/g, ' ')
                        .replace(/&nbsp;/g, ' ')
                        .replace(/&amp;/g, '&')
                        .replace(/&lt;/g, '<')
                        .replace(/&gt;/g, '>')
                        .replace(/&quot;/g, '"')
                        .replace(/&#39;/g, "'")
                        .replace(/\s+/g, ' ')
                        .trim();
        }

        getPlainTextExplanation() {
                if (this.explanationPlainText && this.explanationPlainText.length > 0) {
                        return this.explanationPlainText;
                }
                if (!this.explanationResponse) {
                        return '';
                }
                this.explanationPlainText = this.extractPlainText(this.explanationResponse);
                return this.explanationPlainText;
        }

        buildTemplateValues() {
                const today = new Date();
                const isoDate = today.toISOString().split('T')[0];
                return {
                        '{{selectedText}}': this.selectionData.selectedText || '',
                        '{{paragraphText}}': this.selectionData.paragraphText || '',
                        '{{textBefore}}': this.selectionData.textBefore || '',
                        '{{textAfter}}': this.selectionData.textAfter || '',
                        '{{date}}': isoDate,
                        '{{content}}': this.getPlainTextExplanation(),
                        '{{contentHtml}}': this.explanationResponse || ''
                };
        }

        applyPlaceholders(template, values) {
                if (!template) {
                        return '';
                }

                let result = template;
                Object.entries(values).forEach(([token, value]) => {
                        const safeValue = value != null ? value : '';
                        result = result.split(token).join(safeValue);
                });
                return result;
        }

        buildFrontMatter(properties, values) {
                if (!properties || properties.length === 0) {
                        return '';
                }

                const lines = [];
                properties.forEach((property) => {
                        if (!property || typeof property.key !== 'string') {
                                return;
                        }
                        const trimmedKey = property.key.trim();
                        if (trimmedKey.length === 0) {
                                return;
                        }

                        const rawValue = typeof property.value === 'string' ? property.value : '';
                        const replacedValue = this.applyPlaceholders(rawValue, values);
                        const sanitizedValue = replacedValue
                                .replace(/\\/g, '\\\\')
                                .replace(/\n/g, '\\n')
                                .replace(/"/g, '\\"');

                        lines.push(`${trimmedKey}: "${sanitizedValue}"`);
                });

                if (lines.length === 0) {
                        return '';
                }

                return `---\n${lines.join('\n')}\n---`;
        }

        buildNoteBody(template, values) {
                let workingTemplate = (typeof template === 'string' && template.length > 0)
                        ? template
                        : DEFAULT_NOTE_BODY_TEMPLATE;

                if (!workingTemplate.includes('{{content}}') && values['{{content}}']) {
                        workingTemplate = `${workingTemplate}\n\n${values['{{content}}']}`;
                }

                const populated = this.applyPlaceholders(workingTemplate, values);
                return populated.trim();
        }

        sanitizeFilename(text) {
                if (!text || text.trim().length === 0) {
                        return 'Untitled';
                }
		
		// Remove HTML tags
		let filename = text.replace(/<[^>]*>/g, '');
		
		// Replace invalid characters for filenames
		filename = filename.replace(/[<>:"/\\|?*\x00-\x1f]/g, '');
		
		// Replace multiple spaces with single space and trim
		filename = filename.replace(/\s+/g, ' ').trim();
		
		// Limit length to 100 characters
		if (filename.length > 100) {
			filename = filename.substring(0, 100).trim();
		}
		
		// If empty after sanitization, use default name
		if (filename.length === 0) {
			return 'Untitled';
		}
		
		return filename;
	}

        async createNoteFromExplanation() {
                try {
                        const fileName = this.sanitizeFilename(this.selectionData.selectedText);
                        const noteDirectory = this.settings.noteDirectory || 'Explanations';

                        // Create directory if it doesn't exist
                        const adapter = this.app.vault.adapter;
                        if (!(await adapter.exists(noteDirectory))) {
                                await adapter.mkdir(noteDirectory);
                        }

                        // Generate unique filename
                        let notePath = `${noteDirectory}/${fileName}.md`;
                        let counter = 1;

                        while (await adapter.exists(notePath)) {
                                notePath = `${noteDirectory}/${fileName}-${counter}.md`;
                                counter++;
                        }

                        const templateValues = this.buildTemplateValues();
                        const frontMatter = this.buildFrontMatter(this.noteProperties, templateValues);
                        let body = this.buildNoteBody(this.noteBodyTemplate, templateValues);
                        if (!body || body.trim().length === 0) {
                                body = templateValues['{{content}}'] || '';
                        }

                        const sections = [];
                        if (frontMatter) {
                                sections.push(frontMatter);
                        }
                        if (body) {
                                sections.push(body);
                        }

                        const noteContent = sections.join('\n\n');

                        await this.app.vault.create(notePath, noteContent);

                        return notePath;
                } catch (error) {
                        console.error('Error creating note:', error);
                        throw error;
		}
	}

	getLinkTextFromNotePath(notePath) {
		const fileName = notePath.split('/').pop().replace('.md', '');
		return `[[${fileName}]]`;
	}

	replaceSelectionWithLink(notePath) {
		const editor = this.selectionData.editor;
		if (!editor) {
			console.warn('Editor not available - skipping text replacement');
			return false;
		}

		const linkText = this.getLinkTextFromNotePath(notePath);
		
		try {
			const selection = editor.getSelection();
			if (selection && selection === this.selectionData.selectedText) {
				editor.replaceSelection(linkText);
				return true;
			}

			const cursor = editor.getCursor();
			const currentLine = editor.getLine(cursor.line);
			const textIndex = currentLine.indexOf(this.selectionData.selectedText);
			if (textIndex !== -1) {
				const lineNumber = cursor.line;
				const from = { line: lineNumber, ch: textIndex };
				const to = { line: lineNumber, ch: textIndex + this.selectionData.selectedText.length };
				editor.replaceRange(linkText, from, to);
				return true;
			}

			editor.replaceSelection(linkText);
			return true;
		} catch (error) {
			console.error('Error replacing selection with link:', error);
			editor.replaceSelection(linkText);
			return true;
		}
	}

	findSelectionIndexInContent(content, selectedText, textBefore, textAfter, paragraphText) {
		if (!selectedText) {
			return -1;
		}

		const matchesContext = (candidateIndex) => {
			const beforeSlice = content.substring(Math.max(0, candidateIndex - (textBefore ? textBefore.length : 0)), candidateIndex).trim();
			const afterSlice = content.substring(candidateIndex + selectedText.length, Math.min(content.length, candidateIndex + selectedText.length + (textAfter ? textAfter.length : 0))).trim();
			const beforeMatch = !textBefore || beforeSlice.endsWith(textBefore);
			const afterMatch = !textAfter || afterSlice.startsWith(textAfter);
			return beforeMatch && afterMatch;
		};

		let candidateIndex = content.indexOf(selectedText);
		if (candidateIndex === -1) {
			return -1;
		}

		let index = candidateIndex;
		while (index !== -1) {
			if (matchesContext(index)) {
				return index;
			}
			index = content.indexOf(selectedText, index + 1);
		}

		if (paragraphText) {
			const paragraphIndex = content.indexOf(paragraphText);
			if (paragraphIndex !== -1) {
				const innerIndex = paragraphText.indexOf(selectedText);
				if (innerIndex !== -1) {
					return paragraphIndex + innerIndex;
				}
			}
		}

		return candidateIndex;
	}

	async insertLinkIntoActiveFile(notePath) {
		try {
			const activeFile = this.plugin.app.workspace.getActiveFile();
			if (!activeFile) {
				console.warn('Active file not found - skipping link insertion');
				return false;
			}

			const content = await this.plugin.app.vault.read(activeFile);
			const index = this.findSelectionIndexInContent(
				content,
				this.selectionData.selectedText,
				this.selectionData.textBefore,
				this.selectionData.textAfter,
				this.selectionData.paragraphText
			);

			if (index === -1) {
				console.warn('Selected text not found in active file - skipping link insertion');
				return false;
			}

			const linkText = this.getLinkTextFromNotePath(notePath);
			const updatedContent = `${content.slice(0, index)}${linkText}${content.slice(index + this.selectionData.selectedText.length)}`;
			await this.plugin.app.vault.modify(activeFile, updatedContent);
			return true;
		} catch (error) {
			console.error('Error inserting link into active file:', error);
			return false;
		}
	}

        async createNoteAndLink() {
                try {
                        // Show loading state on button
                        if (this.createNoteButton) {
                                this.createNoteButton.textContent = 'Creating Note...';
                                this.createNoteButton.disabled = true;
                        }
			
                        // Create the note
                        const notePath = await this.createNoteFromExplanation();

                        const normalizedProperties = this.noteProperties
                                .map((property) => ({
                                        key: typeof property.key === 'string' ? property.key.trim() : '',
                                        value: typeof property.value === 'string' ? property.value : ''
                                }))
                                .filter((property) => property.key.length > 0 || property.value.length > 0);

                        this.plugin.settings.noteProperties = normalizedProperties;
                        this.plugin.settings.noteBodyTemplate = this.noteBodyTemplate;
                        await this.plugin.saveSettings();

                        const linkInserted = this.selectionData.editor
                                ? this.replaceSelectionWithLink(notePath)
                                : await this.insertLinkIntoActiveFile(notePath);

			const message = linkInserted
				? `Note created and linked: ${notePath}`
				: `Note created (link not inserted automatically): ${notePath}`;
			new Notice(message);
			
                        // Close the modal
                        this.close();

                } catch (error) {
                        console.error('Error creating note:', error);
                        new Notice(`Error: ${error.message}`);

                        // Reset button state
                        if (this.createNoteButton) {
                                this.createNoteButton.textContent = 'Create Note & Link';
                                this.createNoteButton.disabled = false;
                        }
                }
        }

        onClose() {
                const { contentEl } = this;
                contentEl.empty();
                this.createNoteButton = null;
        }
}

// Settings tab
class TextExplainerSettingTab extends PluginSettingTab {
	constructor(app, plugin) {
		super(app, plugin);
		this.plugin = plugin;
	}

        display() {
                const { containerEl } = this;
                containerEl.empty();
                containerEl.addClass('text-explainer-settings');

                const storedProperties = Array.isArray(this.plugin.settings.noteProperties)
                        ? this.plugin.settings.noteProperties
                        : [];

                this.noteProperties = (storedProperties.length > 0 ? storedProperties : DEFAULT_NOTE_PROPERTIES)
                        .map((prop) => ({
                                key: (prop && typeof prop.key === 'string') ? prop.key : '',
                                value: (prop && typeof prop.value === 'string') ? prop.value : ''
                        }));

                this.noteBodyTemplate = (typeof this.plugin.settings.noteBodyTemplate === 'string'
                        && this.plugin.settings.noteBodyTemplate.trim().length > 0)
                        ? this.plugin.settings.noteBodyTemplate
                        : DEFAULT_NOTE_BODY_TEMPLATE;

                this.noteSettingsContainer = null;

                containerEl.createEl('h2', { text: 'Text Explainer Settings' });

                // API Key setting
                new Setting(containerEl)
			.setName('API Key')
			.setDesc('Your OpenAI API key or OpenAI-compatible API key')
			.addText(text => text
				.setPlaceholder('sk-...')
				.setValue(this.plugin.settings.apiKey)
				.onChange(async (value) => {
					this.plugin.settings.apiKey = value;
					await this.plugin.saveSettings();
				}));

		// Model setting
		new Setting(containerEl)
			.setName('Model')
			.setDesc('LLM model to use')
			.addText(text => text
				.setPlaceholder('gpt-3.5-turbo')
				.setValue(this.plugin.settings.model)
				.onChange(async (value) => {
					this.plugin.settings.model = value;
					await this.plugin.saveSettings();
				}));

		// Language setting
		new Setting(containerEl)
			.setName('Response Language')
			.setDesc('Language for explanations and translations')
			.addDropdown(dropdown => dropdown
				.addOption('Chinese', 'Chinese')
				.addOption('English', 'English')
				.addOption('Spanish', 'Spanish')
				.addOption('French', 'French')
				.addOption('German', 'German')
				.addOption('Japanese', 'Japanese')
				.setValue(this.plugin.settings.language)
				.onChange(async (value) => {
					this.plugin.settings.language = value;
					await this.plugin.saveSettings();
				}));

		// Base URL setting
		new Setting(containerEl)
			.setName('Base URL')
			.setDesc('API base URL')
			.addText(text => text
				.setPlaceholder('https://api.openai.com/v1')
				.setValue(this.plugin.settings.baseUrl)
				.onChange(async (value) => {
					this.plugin.settings.baseUrl = value;
					await this.plugin.saveSettings();
				}));

		// Note directory setting
                new Setting(containerEl)
                        .setName('Note Directory')
                        .setDesc('Directory where explanation notes will be created (relative to vault root)')
                        .addText(text => text
                                .setPlaceholder('Explanations')
                                .setValue(this.plugin.settings.noteDirectory)
                                .onChange(async (value) => {
                                        this.plugin.settings.noteDirectory = value;
                                        await this.plugin.saveSettings();
                                }));

                containerEl.createEl('h3', { text: 'Default Note Configuration' });
                containerEl.createEl('p', {
                        text: 'Preconfigure the YAML properties and body template that new explanation notes start with. You can still tweak them in the popup before saving.'
                });

                this.noteSettingsContainer = containerEl.createDiv('note-configuration');
                this.noteSettingsContainer.addClass('note-settings-configuration');
                this.renderNoteConfigurationSettings();

                // Hotkey settings section
                containerEl.createEl('h3', { text: 'Hotkey Settings' });

		// Hotkey modifiers
		new Setting(containerEl)
			.setName('Hotkey Modifiers')
			.setDesc('Choose modifier keys (hold Ctrl/Cmd to select multiple)')
			.addDropdown(dropdown => {
				dropdown.addOption('Alt', 'Alt only');
				dropdown.addOption('Ctrl', 'Ctrl only');
				dropdown.addOption('Meta', 'Cmd/Win only');
				dropdown.addOption('Shift', 'Shift only');
				dropdown.addOption('Alt,Shift', 'Alt + Shift');
				dropdown.addOption('Ctrl,Shift', 'Ctrl + Shift');
				dropdown.addOption('Meta,Shift', 'Cmd/Win + Shift');
				const currentModifiers = this.plugin.settings.hotkeyModifiers.join(',');
				dropdown.setValue(currentModifiers);
				dropdown.onChange(async (value) => {
					this.plugin.settings.hotkeyModifiers = value.split(',');
					await this.plugin.saveSettings();
					// Re-register the hotkey command
					this.plugin.app.commands.removeCommand('text-explainer:explain-text-hotkey');
					this.plugin.addCommand({
						id: 'explain-text-hotkey',
						name: 'Explain text (hotkey)',
						hotkeys: [{
							modifiers: this.plugin.settings.hotkeyModifiers,
							key: this.plugin.settings.hotkeyKey
						}],
						checkCallback: (checking) => {
							const selectionData = this.plugin.getSelectedText();
							if (selectionData && selectionData.selectedText) {
								if (!checking) this.plugin.explainSelectedText(selectionData.editor);
								return true;
							}
							return false;
						}
					});
				});
			});

		// Hotkey key
		new Setting(containerEl)
			.setName('Hotkey Key')
			.setDesc('The key to press with the modifiers')
			.addText(text => text
				.setPlaceholder('d')
				.setValue(this.plugin.settings.hotkeyKey)
                                .onChange(async (value) => {
                                        if (value.length === 1) {
                                                this.plugin.settings.hotkeyKey = value.toLowerCase();
                                                await this.plugin.saveSettings();
                                                // Re-register the hotkey command
                                                this.plugin.app.commands.removeCommand('text-explainer:explain-text-hotkey');
                                                this.plugin.addCommand({
                                                        id: 'explain-text-hotkey',
                                                        name: 'Explain text (hotkey)',
                                                        hotkeys: [{
                                                                modifiers: this.plugin.settings.hotkeyModifiers,
                                                                key: this.plugin.settings.hotkeyKey
                                                        }],
                                                        checkCallback: (checking) => {
                                                                const selectionData = this.plugin.getSelectedText();
                                                                if (selectionData && selectionData.selectedText) {
                                                                        if (!checking) this.plugin.explainSelectedText(selectionData.editor);
                                                                        return true;
                                                                }
                                                                return false;
                                                        }
                                                });
                                        }
                                }));
        }

        renderNoteConfigurationSettings() {
                if (!this.noteSettingsContainer) {
                        return;
                }

                this.noteSettingsContainer.empty();

                if (!Array.isArray(this.noteProperties)) {
                        this.noteProperties = [];
                }

                if (this.noteProperties.length === 0) {
                        this.noteProperties.push({ key: '', value: '' });
                }

                this.noteSettingsContainer.createEl('h4', { text: 'Predefined properties' });

                const placeholderInfo = this.noteSettingsContainer.createDiv('placeholder-info');
                placeholderInfo.createSpan({ text: 'Available placeholders:' });
                const placeholderList = placeholderInfo.createEl('ul');
                NOTE_PLACEHOLDERS.forEach((placeholder) => {
                        const listItem = placeholderList.createEl('li');
                        listItem.createEl('code', { text: placeholder.token });
                        listItem.createSpan({ text: ` - ${placeholder.description}` });
                });

                const propertiesTable = this.noteSettingsContainer.createEl('table', { cls: 'note-config-table' });
                const tableHead = propertiesTable.createEl('thead');
                const headRow = tableHead.createEl('tr');
                headRow.createEl('th', { text: 'Property' });
                headRow.createEl('th', { text: 'Value or placeholder' });
                headRow.createEl('th', { text: '' });

                const tableBody = propertiesTable.createEl('tbody');

                this.noteProperties.forEach((property, index) => {
                        const row = tableBody.createEl('tr');

                        const keyCell = row.createEl('td');
                        const keyInput = keyCell.createEl('input', {
                                attr: {
                                        type: 'text',
                                        value: property.key || '',
                                        placeholder: 'Property key'
                                }
                        });
                        keyInput.addEventListener('input', () => {
                                this.noteProperties[index].key = keyInput.value;
                                this.persistNoteConfigurationSettings();
                        });

                        const valueCell = row.createEl('td');
                        const valueWrapper = valueCell.createDiv('value-input-wrapper');
                        const valueInput = valueWrapper.createEl('input', {
                                attr: {
                                        type: 'text',
                                        value: property.value || '',
                                        placeholder: 'Value or choose a placeholder'
                                }
                        });
                        valueInput.addEventListener('input', () => {
                                this.noteProperties[index].value = valueInput.value;
                                this.persistNoteConfigurationSettings();
                        });

                        const placeholderSelect = valueWrapper.createEl('select', { cls: 'placeholder-select' });
                        placeholderSelect.createEl('option', { value: '', text: 'Insert placeholder...' });
                        NOTE_PLACEHOLDERS.forEach((placeholder) => {
                                const option = placeholderSelect.createEl('option', {
                                        value: placeholder.token,
                                        text: placeholder.token
                                });
                                option.setAttr('data-description', placeholder.description);
                                option.setAttr('title', placeholder.description);
                        });
                        placeholderSelect.addEventListener('change', (event) => {
                                const selectValue = event.target.value;
                                if (selectValue) {
                                        valueInput.value = selectValue;
                                        this.noteProperties[index].value = selectValue;
                                        this.persistNoteConfigurationSettings();
                                        event.target.value = '';
                                }
                        });

                        const removeCell = row.createEl('td', { cls: 'note-config-actions' });
                        const removeButton = removeCell.createEl('button', {
                                text: 'Remove',
                                cls: 'note-config-remove'
                        });
                        removeButton.addEventListener('click', (event) => {
                                event.preventDefault();
                                this.noteProperties.splice(index, 1);
                                this.renderNoteConfigurationSettings();
                                this.persistNoteConfigurationSettings();
                        });
                });

                const addRowButton = this.noteSettingsContainer.createEl('button', {
                        text: 'Add property',
                        cls: 'note-config-add-row'
                });
                addRowButton.addEventListener('click', (event) => {
                        event.preventDefault();
                        this.noteProperties.push({ key: '', value: '' });
                        this.renderNoteConfigurationSettings();
                });

                const templateSection = this.noteSettingsContainer.createDiv('note-template-section');
                const templateLabel = templateSection.createEl('label', {
                        attr: { for: 'default-note-template-input' },
                        text: 'Note body template'
                });
                templateLabel.createSpan({ text: ' (include {{content}} where the explanation should appear)' });
                const templateTextarea = templateSection.createEl('textarea', {
                        cls: 'note-template-input',
                        attr: { id: 'default-note-template-input' }
                });
                templateTextarea.value = this.noteBodyTemplate || '';
                templateTextarea.addEventListener('input', () => {
                        this.noteBodyTemplate = templateTextarea.value;
                        this.persistNoteConfigurationSettings();
                });
        }

        async persistNoteConfigurationSettings() {
                if (!this.plugin || !this.plugin.settings) {
                        return;
                }

                const normalizedProperties = Array.isArray(this.noteProperties)
                        ? this.noteProperties
                                .map((property) => ({
                                        key: typeof property.key === 'string' ? property.key.trim() : '',
                                        value: typeof property.value === 'string' ? property.value : ''
                                }))
                                .filter((property) => property.key.length > 0 || property.value.length > 0)
                        : [];

                this.plugin.settings.noteProperties = normalizedProperties.map((property) => ({ ...property }));
                this.plugin.settings.noteBodyTemplate = typeof this.noteBodyTemplate === 'string'
                        ? this.noteBodyTemplate
                        : '';

                await this.plugin.saveSettings();
        }
}

module.exports = TextExplainerPlugin;
