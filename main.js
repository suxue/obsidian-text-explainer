const { Plugin, Modal, Setting, Notice, MarkdownView, PluginSettingTab } = require('obsidian');

const DEFAULT_NOTE_PROPERTIES = [
        { key: 'title', value: '{{selectedText}}' },
        { key: 'created', value: '{{date}}' },
        { key: 'source', value: '{{paragraphText}}' }
];

const DEFAULT_NOTE_BODY_TEMPLATE = `# {{selectedText}}

> Explanation generated on {{date}}

## Original Context
{{selectedText}}

## Explanation
{{content}}

{{audioSection}}

---
*Generated by Text Explainer Plugin*`;

const NOTE_PLACEHOLDERS = [
        { token: '{{selectedText}}', description: 'Original selected text' },
        { token: '{{paragraphText}}', description: 'Paragraph containing the selection' },
        { token: '{{textBefore}}', description: 'Text that appears before the selection' },
        { token: '{{textAfter}}', description: 'Text that appears after the selection' },
        { token: '{{date}}', description: 'Current date in YYYY-MM-DD format' },
        { token: '{{content}}', description: 'Generated explanation as plain text' },
        { token: '{{contentHtml}}', description: 'Generated explanation with HTML formatting' },
        { token: '{{audioUrl}}', description: 'Direct URL to the generated audio (if available)' },
        { token: '{{audioHtml}}', description: 'Audio player HTML markup (if available)' },
        { token: '{{audioSection}}', description: 'Markdown section that includes the audio player when available' }
];

const PROMPT_PLACEHOLDERS = [
        { token: '{{selectedText}}', description: 'Original selected text' },
        { token: '{{language}}', description: 'Configured response language' },
        { token: '{{paragraphText}}', description: 'Paragraph containing the selection' },
        { token: '{{textBefore}}', description: 'Text that appears before the selection' },
        { token: '{{textAfter}}', description: 'Text that appears after the selection' },
        { token: '{{contextSection}}', description: 'Formatted context block combining surrounding text' },
        { token: '{{sampleSentenceLanguage}}', description: 'Language to use for sample sentences' },
        { token: '{{pronunciationHint}}', description: 'Optional IPA hint when the response language is Chinese' },
        { token: '{{noPinyinInstruction}}', description: 'Instruction to avoid Pinyin when the response language is Chinese' }
];

const DEFAULT_PROMPT_TEMPLATE = `Provide an explanation for the word: "{{selectedText}}{{pronunciationHint}}" in {{language}} without commentary.{{noPinyinInstruction}}

Use the context from the surrounding paragraph to inform your explanation when relevant:

{{contextSection}}

# Consider these scenarios:

## Names
If "{{selectedText}}" is a person's name, company name, or organization name, provide a brief description (e.g., who they are or what they do).

## Technical Terms
If "{{selectedText}}" is a technical term or jargon
- give a concise definition and explain.
- Some best practice of using it
- Explain how it works.
- No need example sentence for the technical term.

## Normal Words
- For any other word, explain its meaning and provide 1-2 example sentences with the word in {{sampleSentenceLanguage}}.

# Format
- Output the words first, then the explanation, and then the example sentences if necessary.
- No extra explanation
- Remember to using proper html format like <p> <b> <i> <a> <li> <ol> <ul> to improve readability.`;

// Default settings
const DEFAULT_SETTINGS = {
        model: "gpt-3.5-turbo",
        apiKey: "",
        baseUrl: "https://api.openai.com/v1",
        language: "Chinese",
        hotkeyModifiers: ["Alt"],
        hotkeyKey: "d",
        noteDirectory: "Explanations",
        noteProperties: DEFAULT_NOTE_PROPERTIES.map(prop => ({ ...prop })),
        noteBodyTemplate: DEFAULT_NOTE_BODY_TEMPLATE,
        promptTemplate: DEFAULT_PROMPT_TEMPLATE,
        ttsModel: ""
};

// Main plugin class
class TextExplainerPlugin extends Plugin {
	async onload() {
		await this.loadSettings();

		// Add ribbon icon
		this.addRibbonIcon('message-circle', 'Text Explainer', () => {
			this.explainSelectedText();
		});

		// Add command (works in edit and reader mode)
		this.addCommand({
			id: 'explain-selected-text',
			name: 'Explain selected text',
			checkCallback: (checking) => {
				const selectionData = this.getSelectedText();
				if (selectionData && selectionData.selectedText) {
					if (!checking) this.explainSelectedText(selectionData.editor);
					return true;
				}
				return false;
			}
		});

		// Register hotkey (works in edit and reader mode)
		this.addCommand({
			id: 'explain-text-hotkey',
			name: 'Explain text (hotkey)',
			hotkeys: [{
				modifiers: this.settings.hotkeyModifiers,
				key: this.settings.hotkeyKey
			}],
			checkCallback: (checking) => {
				const selectionData = this.getSelectedText();
				if (selectionData && selectionData.selectedText) {
					if (!checking) this.explainSelectedText(selectionData.editor);
					return true;
				}
				return false;
			}
		});

		// Add settings tab
		this.addSettingTab(new TextExplainerSettingTab(this.app, this));

		console.log('Text Explainer plugin loaded');
	}

	onunload() {
		console.log('Text Explainer plugin unloaded');
	}

        async loadSettings() {
                const loadedData = await this.loadData();
                this.settings = Object.assign({}, DEFAULT_SETTINGS, loadedData);

                if (!Array.isArray(this.settings.noteProperties) || this.settings.noteProperties.length === 0) {
                        this.settings.noteProperties = DEFAULT_NOTE_PROPERTIES.map(prop => ({ ...prop }));
                } else {
                        this.settings.noteProperties = this.settings.noteProperties.map((prop) => ({
                                key: (prop && typeof prop.key === 'string') ? prop.key : '',
                                value: (prop && typeof prop.value === 'string') ? prop.value : ''
                        }));
                }

                if (!this.settings.noteBodyTemplate || typeof this.settings.noteBodyTemplate !== 'string') {
                        this.settings.noteBodyTemplate = DEFAULT_NOTE_BODY_TEMPLATE;
                }

                if (!this.settings.promptTemplate || typeof this.settings.promptTemplate !== 'string') {
                        this.settings.promptTemplate = DEFAULT_PROMPT_TEMPLATE;
                }

                if (typeof this.settings.ttsModel !== 'string') {
                        this.settings.ttsModel = '';
                } else {
                        this.settings.ttsModel = this.settings.ttsModel.trim();
                }
        }

	async saveSettings() {
		await this.saveData(this.settings);
	}

	// Get selected text from the active editor or DOM selection
	getSelectedText(editor) {
		if (!editor) {
			const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
			if (activeView && activeView.editor) {
				editor = activeView.editor;
			}
		}

		// Try to get selection from editor (edit mode)
		if (editor) {
			const selection = editor.getSelection();
			if (selection) {
				// Get context around selection
				const cursor = editor.getCursor('from');
				const line = editor.getLine(cursor.line);
				const doc = editor.getValue();
				const selectionStart = editor.posToOffset(editor.getCursor('from'));
				const selectionEnd = editor.posToOffset(editor.getCursor('to'));

				// Get surrounding context
				const contextRange = 200;
				const textBefore = doc.substring(Math.max(0, selectionStart - contextRange), selectionStart).trim();
				const textAfter = doc.substring(selectionEnd, Math.min(doc.length, selectionEnd + contextRange)).trim();

				return {
					selectedText: selection,
					textBefore,
					textAfter,
					paragraphText: line,
					editor
				};
			}
		}

		// Try to get selection from DOM (reader mode)
		const selection = window.getSelection();
		if (selection && selection.toString().trim()) {
			const selectedText = selection.toString().trim();
			
			// Get context from surrounding DOM elements
			const range = selection.getRangeAt(0);
			const container = range.commonAncestorContainer;
			
			// Find the paragraph or container element
			let parentElement = container.nodeType === Node.TEXT_NODE ? container.parentElement : container;
			while (parentElement && !['P', 'DIV', 'LI', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6'].includes(parentElement.tagName)) {
				parentElement = parentElement.parentElement;
			}
			
			const paragraphText = parentElement ? parentElement.textContent.trim() : selectedText;
			
			// Get surrounding context by looking at siblings
			let textBefore = '';
			let textAfter = '';
			
			if (parentElement) {
				const fullText = parentElement.textContent;
				const selectedIndex = fullText.indexOf(selectedText);
				if (selectedIndex !== -1) {
					const contextRange = 200;
					textBefore = fullText.substring(Math.max(0, selectedIndex - contextRange), selectedIndex).trim();
					textAfter = fullText.substring(selectedIndex + selectedText.length, Math.min(fullText.length, selectedIndex + selectedText.length + contextRange)).trim();
				}
			}

			return {
				selectedText,
				textBefore,
				textAfter,
				paragraphText,
				editor: null // No editor in reader mode
			};
		}

		return null;
	}

	// Main function to explain selected text
	async explainSelectedText(editor) {
		const selectionData = this.getSelectedText(editor);
		
		if (!selectionData || !selectionData.selectedText) {
			new Notice('No text selected');
			return;
		}

		if (!this.settings.apiKey) {
			new Notice('Please configure your API key in settings');
			return;
		}

		// Create and show explanation modal
		const modal = new ExplanationModal(this.app, selectionData, this.settings, this);
		modal.open();
	}

	// Generate prompt based on text length and type
	getPrompt(selectedText, paragraphText, textBefore, textAfter) {
		const wordsCount = selectedText.split(' ').length;
		const systemPrompt = `Respond in ${this.settings.language} with HTML tags to improve readability.
- Prioritize clarity and conciseness
- Use bullet points when appropriate`;

		if (wordsCount >= 500) {
			return {
				prompt: `Create a structured summary in ${this.settings.language}:
- Identify key themes and concepts
- Extract 3-5 main points
- Use nested <ul> lists for hierarchy
- Keep bullets concise

for the following selected text:

${selectedText}
`,
				systemPrompt
			};
		}

		// For short text that looks like a sentence, offer translation
		if (wordsCount >= 5) {
			return {
				prompt: `Translate exactly to ${this.settings.language} without commentary:
- Preserve technical terms and names
- Maintain original punctuation
- Match formal/informal tone of source

for the following selected text:

${selectedText}
`,
				systemPrompt
			};
		}

                const pinYinExtraPrompt = this.settings.language === "Chinese" ? ' DO NOT add Pinyin for it.' : '';
                const ipaExtraPrompt = this.settings.language === "Chinese" ? '(with IPA if necessary)' : '';
                const asciiChars = selectedText.replace(/[\s\.,\-_'\"!?()]/g, '')
                        .split('')
                        .filter(char => char.charCodeAt(0) <= 127).length;
                const sampleSentenceLanguage = selectedText.length === asciiChars ? "English" : this.settings.language;

                // Context prompt
                const contextPrompt = textBefore || textAfter ?
                        `# Context:
## Before selected text:
${textBefore || 'None'}
## Selected text:
${selectedText}
## After selected text:
${textAfter || 'None'}` : paragraphText;

                const promptTemplate = (typeof this.settings.promptTemplate === 'string'
                        && this.settings.promptTemplate.trim().length > 0)
                        ? this.settings.promptTemplate
                        : DEFAULT_PROMPT_TEMPLATE;

                const replaceTokens = (template, values) => {
                        if (typeof template !== 'string' || template.length === 0) {
                                return '';
                        }

                        let result = template;
                        Object.entries(values).forEach(([token, value]) => {
                                const safeValue = value != null ? String(value) : '';
                                result = result.split(token).join(safeValue);
                        });
                        return result;
                };

                const promptValues = {
                        '{{selectedText}}': selectedText,
                        '{{language}}': this.settings.language || '',
                        '{{paragraphText}}': paragraphText || '',
                        '{{textBefore}}': textBefore || '',
                        '{{textAfter}}': textAfter || '',
                        '{{contextSection}}': contextPrompt || '',
                        '{{contextPrompt}}': contextPrompt || '',
                        '{{sampleSentenceLanguage}}': sampleSentenceLanguage || '',
                        '{{pronunciationHint}}': ipaExtraPrompt,
                        '{{noPinyinInstruction}}': pinYinExtraPrompt
                };

                // Explain words prompt
                return {
                        prompt: replaceTokens(promptTemplate, promptValues),
                        systemPrompt
                };
        }

        // Call LLM API
        async callLLM(prompt, systemPrompt, progressCallback) {
                if (!this.settings.apiKey) {
                        throw new Error("Please set up your API key in the settings.");
                }

		const requestBody = {
			model: this.settings.model,
			messages: [
				{
					role: "system",
					content: systemPrompt
				},
				{
					role: "user",
					content: prompt
				}
			],
			temperature: 0.7,
			max_tokens: 2048
		};

		const response = await fetch(`${this.settings.baseUrl}/chat/completions`, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				'Authorization': `Bearer ${this.settings.apiKey}`
			},
			body: JSON.stringify(requestBody)
		});

		if (!response.ok) {
			const errorText = await response.text();
			throw new Error(`API request failed: ${response.status} ${response.statusText}. ${errorText}`);
		}

		const data = await response.json();
		
		if (!data.choices || !data.choices[0] || !data.choices[0].message) {
			throw new Error('No response received from the model');
		}

		const text = data.choices[0].message.content;
		
		// Call progress callback if provided
		if (progressCallback) {
			progressCallback(text, text);
                }

                return text;
        }

        async callTextToSpeech(prompt, systemPrompt) {
                if (!this.settings.apiKey) {
                        throw new Error("Please set up your API key in the settings.");
                }

                if (!this.settings.ttsModel || this.settings.ttsModel.trim().length === 0) {
                        throw new Error('Text-to-speech model is not configured.');
                }

                const messages = [];
                if (systemPrompt && systemPrompt.trim().length > 0) {
                        messages.push({
                                role: 'system',
                                content: systemPrompt
                        });
                }

                messages.push({
                        role: 'user',
                        content: prompt
                });

                const requestBody = {
                        model: this.settings.ttsModel,
                        messages,
                        temperature: 0.7,
                        max_tokens: 2048
                };

                const response = await fetch(`${this.settings.baseUrl}/chat/completions`, {
                        method: 'POST',
                        headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${this.settings.apiKey}`
                        },
                        body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`TTS request failed: ${response.status} ${response.statusText}. ${errorText}`);
                }

                const data = await response.json();
                const messageContent = data?.choices?.[0]?.message?.content;

                const extractAudioUrl = (content) => {
                        if (!content) {
                                return '';
                        }

                        if (typeof content === 'string') {
                                const trimmed = content.trim();

                                if (trimmed.startsWith('{') || trimmed.startsWith('[')) {
                                        try {
                                                const parsed = JSON.parse(trimmed);
                                                if (typeof parsed === 'string') {
                                                        return parsed;
                                                }
                                                if (Array.isArray(parsed)) {
                                                        const firstItem = parsed.find((value) => typeof value === 'string');
                                                        if (firstItem) {
                                                                return firstItem;
                                                        }
                                                        if (parsed.length > 0 && parsed[0] && typeof parsed[0].url === 'string') {
                                                                return parsed[0].url;
                                                        }
                                                }
                                                if (parsed && typeof parsed.url === 'string') {
                                                        return parsed.url;
                                                }
                                        } catch (error) {
                                                // Ignore JSON parse errors and fall back to regex extraction
                                        }
                                }

                                const urlMatch = trimmed.match(/https?:\/\/[^\s"']+/);
                                if (urlMatch && urlMatch[0]) {
                                        return urlMatch[0];
                                }

                                return trimmed;
                        }

                        if (Array.isArray(content)) {
                                const stringMatch = content.find((value) => typeof value === 'string');
                                if (stringMatch) {
                                        return extractAudioUrl(stringMatch);
                                }
                                const textSegment = content.find((value) => value && typeof value === 'object' && typeof value.text === 'string');
                                if (textSegment) {
                                        return extractAudioUrl(textSegment.text);
                                }
                                const urlMatch = content.find((value) => value && typeof value.url === 'string');
                                if (urlMatch) {
                                        return urlMatch.url;
                                }
                        }

                        if (content && typeof content === 'object' && typeof content.url === 'string') {
                                return content.url;
                        }

                        return '';
                };

                const audioUrl = extractAudioUrl(messageContent);

                if (!audioUrl || typeof audioUrl !== 'string') {
                        throw new Error('No audio URL returned from the TTS model.');
                }

                const trimmedUrl = audioUrl.trim();

                if (!/^https?:\/\//i.test(trimmedUrl)) {
                        throw new Error('The TTS model response did not include a valid audio URL.');
                }

                return trimmedUrl;
        }
}

// Modal for displaying explanations
class ExplanationModal extends Modal {
        constructor(app, selectionData, settings, plugin) {
                super(app);
                this.selectionData = selectionData;
                this.settings = settings;
                this.plugin = plugin;
                this.noteProperties = (settings.noteProperties || DEFAULT_NOTE_PROPERTIES).map(prop => ({
                        key: (prop && typeof prop.key === 'string') ? prop.key : '',
                        value: (prop && typeof prop.value === 'string') ? prop.value : ''
                }));
                this.noteBodyTemplate = (typeof settings.noteBodyTemplate === 'string' && settings.noteBodyTemplate.trim().length > 0)
                        ? settings.noteBodyTemplate
                        : DEFAULT_NOTE_BODY_TEMPLATE;
                this.createNoteButton = null;
                this.audioPromise = null;
                this.audioUrl = '';
                this.audioHtml = '';
                this.audioContainer = null;
        }

        onOpen() {
                const { contentEl } = this;
                contentEl.addClass('text-explainer-modal');

                // Add title
		contentEl.createEl('h3', { text: 'Text Explanation' });

		// Show selected text
		const selectedDiv = contentEl.createDiv('selected-text');
		selectedDiv.createEl('strong', { text: 'Selected: ' });
		selectedDiv.createSpan({ text: this.selectionData.selectedText });

		// Loading indicator
		const loadingDiv = contentEl.createDiv('loading');
		loadingDiv.innerHTML = '<div class="loading-spinner"></div><span>Generating explanation...</span>';

                // Content area
                const contentDiv = contentEl.createDiv('explanation-content');
                contentDiv.style.display = 'none';

                // Audio area
                this.audioContainer = contentEl.createDiv('explanation-audio');
                this.audioContainer.style.display = 'none';
                this.audioContainer.addClass('explanation-audio-container');

                // Error area
                const errorDiv = contentEl.createDiv('error-message');
                errorDiv.style.display = 'none';

                // Note configuration container
                this.noteConfigContainer = contentEl.createDiv('note-configuration');
                this.noteConfigContainer.style.display = 'none';
                this.renderNoteConfiguration();

                // Action buttons container
                const actionsDiv = contentEl.createDiv('explanation-actions');
                actionsDiv.style.display = 'none';

                // Create Note & Link button
                const createNoteBtn = actionsDiv.createEl('button', {
                        text: 'Create Note & Link',
                        cls: 'mod-cta'
                });
                createNoteBtn.addEventListener('click', () => this.createNoteAndLink());
                this.createNoteButton = createNoteBtn;

                // Start explanation process
                this.generateExplanation(loadingDiv, contentDiv, errorDiv, actionsDiv);
        }

        renderNoteConfiguration() {
                if (!this.noteConfigContainer) {
                        return;
                }

                this.noteConfigContainer.empty();

                this.noteConfigContainer.createEl('h4', { text: 'Configure generated note' });

                const placeholderInfo = this.noteConfigContainer.createDiv('placeholder-info');
                placeholderInfo.createSpan({ text: 'Available placeholders:' });
                const placeholderList = placeholderInfo.createEl('ul');
                NOTE_PLACEHOLDERS.forEach((placeholder) => {
                        const listItem = placeholderList.createEl('li');
                        listItem.createEl('code', { text: placeholder.token });
                        listItem.createSpan({ text: ` - ${placeholder.description}` });
                });

                const propertiesTable = this.noteConfigContainer.createEl('table', { cls: 'note-config-table' });
                const tableHead = propertiesTable.createEl('thead');
                const headRow = tableHead.createEl('tr');
                headRow.createEl('th', { text: 'Property' });
                headRow.createEl('th', { text: 'Value or placeholder' });
                headRow.createEl('th', { text: '' });

                const tableBody = propertiesTable.createEl('tbody');

                if (!this.noteProperties || this.noteProperties.length === 0) {
                        this.noteProperties = [{ key: '', value: '' }];
                }

                this.noteProperties.forEach((property, index) => {
                        const row = tableBody.createEl('tr');

                        const keyCell = row.createEl('td');
                        const keyInput = keyCell.createEl('input', {
                                attr: {
                                        type: 'text',
                                        value: property.key || '',
                                        placeholder: 'Property key'
                                }
                        });
                        keyInput.addEventListener('input', () => {
                                this.noteProperties[index].key = keyInput.value;
                        });

                        const valueCell = row.createEl('td');
                        const valueWrapper = valueCell.createDiv('value-input-wrapper');
                        const valueInput = valueWrapper.createEl('input', {
                                attr: {
                                        type: 'text',
                                        value: property.value || '',
                                        placeholder: 'Value or choose a placeholder'
                                }
                        });
                        valueInput.addEventListener('input', () => {
                                this.noteProperties[index].value = valueInput.value;
                        });

                        const placeholderSelect = valueWrapper.createEl('select', { cls: 'placeholder-select' });
                        placeholderSelect.createEl('option', { value: '', text: 'Insert placeholder...' });
                        NOTE_PLACEHOLDERS.forEach((placeholder) => {
                                const option = placeholderSelect.createEl('option', {
                                        value: placeholder.token,
                                        text: placeholder.token
                                });
                                option.setAttr('data-description', placeholder.description);
                                option.setAttr('title', placeholder.description);
                        });
                        placeholderSelect.addEventListener('change', (event) => {
                                const selectValue = event.target.value;
                                if (selectValue) {
                                        valueInput.value = selectValue;
                                        this.noteProperties[index].value = selectValue;
                                        event.target.value = '';
                                }
                        });

                        const removeCell = row.createEl('td', { cls: 'note-config-actions' });
                        const removeButton = removeCell.createEl('button', {
                                text: 'Remove',
                                cls: 'note-config-remove'
                        });
                        removeButton.addEventListener('click', (event) => {
                                event.preventDefault();
                                this.noteProperties.splice(index, 1);
                                this.renderNoteConfiguration();
                        });
                });

                const addRowButton = this.noteConfigContainer.createEl('button', {
                        text: 'Add property',
                        cls: 'note-config-add-row'
                });
                addRowButton.addEventListener('click', (event) => {
                        event.preventDefault();
                        this.noteProperties.push({ key: '', value: '' });
                        this.renderNoteConfiguration();
                });

                const templateSection = this.noteConfigContainer.createDiv('note-template-section');
                const templateLabel = templateSection.createEl('label', {
                        attr: { for: 'note-template-input' },
                        text: 'Note body template'
                });
                templateLabel.createSpan({ text: ' (include {{content}} where the explanation should appear)' });
                const templateTextarea = templateSection.createEl('textarea', {
                        cls: 'note-template-input',
                        attr: { id: 'note-template-input' }
                });
                templateTextarea.value = this.noteBodyTemplate || '';
                templateTextarea.addEventListener('input', () => {
                        this.noteBodyTemplate = templateTextarea.value;
                });
        }

        async generateExplanation(loadingDiv, contentDiv, errorDiv, actionsDiv) {
                const audioContainer = this.audioContainer;

                if (audioContainer) {
                        audioContainer.empty();
                        audioContainer.style.display = 'none';
                        audioContainer.removeClass('audio-error');
                        audioContainer.removeClass('audio-loading');
                        audioContainer.removeClass('audio-ready');
                }

                this.audioPromise = null;
                this.audioUrl = '';
                this.audioHtml = '';

                try {
                        const { prompt, systemPrompt } = this.plugin.getPrompt(
                                this.selectionData.selectedText,
                                this.selectionData.paragraphText,
                                this.selectionData.textBefore,
                                this.selectionData.textAfter
                        );

                        const shouldGenerateAudio = Boolean(this.plugin.settings.ttsModel && this.plugin.settings.ttsModel.trim().length > 0);
                        const selectedTextForAudio = (this.selectionData.selectedText || '').trim();

                        if (shouldGenerateAudio && audioContainer) {
                                if (selectedTextForAudio.length > 0) {
                                        audioContainer.style.display = 'block';
                                        audioContainer.addClass('audio-loading');
                                        audioContainer.createEl('p', { text: 'Generating audio for selected text...' });
                                } else {
                                        audioContainer.empty();
                                        audioContainer.style.display = 'none';
                                }
                        }

                        if (shouldGenerateAudio && selectedTextForAudio.length > 0) {
                                const ttsSystemPrompt = '';
                                const ttsPrompt = selectedTextForAudio + " ";

                                this.audioPromise = (async () => {
                                        try {
                                                const audioUrl = await this.plugin.callTextToSpeech(ttsPrompt, ttsSystemPrompt);
                                                this.audioUrl = audioUrl;
                                                this.audioHtml = this.buildAudioHtml(audioUrl);

                                                if (audioContainer && audioContainer.isConnected) {
                                                        this.renderAudioPlayer(audioContainer, audioUrl);
                                                }

                                                return { audioUrl };
                                        } catch (audioError) {
                                                console.error('Error generating audio:', audioError);
                                                this.audioUrl = '';
                                                this.audioHtml = '';

                                                if (audioContainer && audioContainer.isConnected) {
                                                        this.renderAudioError(audioContainer, audioError);
                                                }

                                                return { error: audioError };
                                        }
                                })();
                        }

                        const response = await this.plugin.callLLM(prompt, systemPrompt, (textChunk, currentFullText) => {
                                // Hide loading and show content on first chunk
                                if (loadingDiv.style.display !== 'none') {
                                        loadingDiv.style.display = 'none';
                                        contentDiv.style.display = 'block';
                                }

                                // Update content
                                this.updateContentDisplay(contentDiv, currentFullText || textChunk);
                        });

                        // Final update
                        loadingDiv.style.display = 'none';
                        contentDiv.style.display = 'block';
                        actionsDiv.style.display = 'block';
                        this.updateContentDisplay(contentDiv, response);
                        this.explanationResponse = response;
                        this.explanationPlainText = this.extractPlainText(response);
                        if (this.noteConfigContainer) {
                                this.noteConfigContainer.style.display = 'block';
                        }

                } catch (error) {
                        console.error('Error generating explanation:', error);
                        loadingDiv.style.display = 'none';
                        errorDiv.style.display = 'block';
                        errorDiv.innerHTML = `<strong>Error:</strong> ${error.message}`;

                        if (audioContainer) {
                                audioContainer.empty();
                                audioContainer.style.display = 'none';
                        }
                }
        }

        updateContentDisplay(contentDiv, text) {
                if (!text) return;

                text = text.trim();
                if (text.length === 0) return;

		try {
			// Remove code block markers if present
			if (text.startsWith('```')) {
				if (text.endsWith('```')) {
					text = text.split('\n').slice(1, -1).join('\n');
				} else {
					text = text.split('\n').slice(1).join('\n');
				}
			}
			
			// If not HTML, wrap in paragraph
			if (!text.startsWith('<')) {
				text = `<p>${text.replace(/\n/g, '<br>')}</p>`;
			}
			
			contentDiv.innerHTML = text;
		} catch (e) {
                        console.error(`Error parsing content: ${e.message}`);
                        contentDiv.innerHTML = `<p>${text.replace(/\n/g, '<br>')}</p>`;
                }
        }

        extractPlainText(html) {
                if (!html) {
                        return '';
                }

                try {
                        if (typeof document !== 'undefined') {
                                const tempDiv = document.createElement('div');
                                tempDiv.innerHTML = html;
                                return (tempDiv.textContent || tempDiv.innerText || '').trim();
                        }
                } catch (error) {
                        console.warn('Fallback plain text conversion used:', error);
                }

                return html
                        .replace(/<[^>]*>/g, ' ')
                        .replace(/&nbsp;/g, ' ')
                        .replace(/&amp;/g, '&')
                        .replace(/&lt;/g, '<')
                        .replace(/&gt;/g, '>')
                        .replace(/&quot;/g, '"')
                        .replace(/&#39;/g, "'")
                        .replace(/\s+/g, ' ')
                        .trim();
        }

        getPlainTextExplanation() {
                if (this.explanationPlainText && this.explanationPlainText.length > 0) {
                        return this.explanationPlainText;
                }
                if (!this.explanationResponse) {
                        return '';
                }
                this.explanationPlainText = this.extractPlainText(this.explanationResponse);
                return this.explanationPlainText;
        }

        buildTemplateValues() {
                const today = new Date();
                const isoDate = today.toISOString().split('T')[0];
                const audioUrl = this.audioUrl || '';
                const audioHtml = this.audioHtml || '';
                const audioSection = audioHtml
                        ? `## Audio Version\n${audioHtml}`
                        : '';

                return {
                        '{{selectedText}}': this.selectionData.selectedText || '',
                        '{{paragraphText}}': this.selectionData.paragraphText || '',
                        '{{textBefore}}': this.selectionData.textBefore || '',
                        '{{textAfter}}': this.selectionData.textAfter || '',
                        '{{date}}': isoDate,
                        '{{content}}': this.getPlainTextExplanation(),
                        '{{contentHtml}}': this.explanationResponse || '',
                        '{{audioUrl}}': audioUrl,
                        '{{audioHtml}}': audioHtml,
                        '{{audioSection}}': audioSection
                };
        }

        buildAudioHtml(audioUrl) {
                if (!audioUrl || typeof audioUrl !== 'string') {
                        return '';
                }

                const escapedUrl = audioUrl
                        .replace(/&/g, '&amp;')
                        .replace(/"/g, '&quot;')
                        .replace(/'/g, '&#39;');
                return `<audio controls src="${escapedUrl}">Your browser does not support the audio element. <a href="${escapedUrl}">Download audio</a></audio>`;
        }

        renderAudioPlayer(container, audioUrl) {
                if (!container) {
                        return;
                }

                container.empty();
                container.style.display = 'block';
                container.removeClass('audio-loading');
                container.removeClass('audio-error');
                container.addClass('audio-ready');

                container.createEl('h4', { text: 'Audio Explanation' });
                const audioElement = container.createEl('audio', {
                        attr: {
                                controls: 'controls',
                                src: audioUrl
                        }
                });
                audioElement.addClass('audio-player');
                audioElement.style.width = '100%';

                const downloadParagraph = container.createEl('p', { cls: 'audio-download' });
                downloadParagraph.createEl('a', {
                        text: 'Download audio',
                        attr: {
                                href: audioUrl,
                                target: '_blank',
                                rel: 'noopener noreferrer'
                        }
                });
        }

        renderAudioError(container, error) {
                if (!container) {
                        return;
                }

                container.empty();
                container.style.display = 'block';
                container.removeClass('audio-loading');
                container.removeClass('audio-ready');
                container.addClass('audio-error');

                const message = (error && error.message) ? error.message : 'Unable to generate audio.';
                container.createEl('p', { text: `Audio unavailable: ${message}` });
        }

        applyPlaceholders(template, values) {
                if (!template) {
                        return '';
                }

                let result = template;
                Object.entries(values).forEach(([token, value]) => {
                        const safeValue = value != null ? value : '';
                        result = result.split(token).join(safeValue);
                });
                return result;
        }

        buildFrontMatter(properties, values) {
                if (!properties || properties.length === 0) {
                        return '';
                }

                const lines = [];
                properties.forEach((property) => {
                        if (!property || typeof property.key !== 'string') {
                                return;
                        }
                        const trimmedKey = property.key.trim();
                        if (trimmedKey.length === 0) {
                                return;
                        }

                        const rawValue = typeof property.value === 'string' ? property.value : '';
                        const replacedValue = this.applyPlaceholders(rawValue, values);
                        const sanitizedValue = replacedValue
                                .replace(/\\/g, '\\\\')
                                .replace(/\n/g, '\\n')
                                .replace(/"/g, '\\"');

                        lines.push(`${trimmedKey}: "${sanitizedValue}"`);
                });

                if (lines.length === 0) {
                        return '';
                }

                return `---\n${lines.join('\n')}\n---`;
        }

        buildNoteBody(template, values) {
                let workingTemplate = (typeof template === 'string' && template.length > 0)
                        ? template
                        : DEFAULT_NOTE_BODY_TEMPLATE;

                if (!workingTemplate.includes('{{content}}') && values['{{content}}']) {
                        workingTemplate = `${workingTemplate}\n\n${values['{{content}}']}`;
                }

                const populated = this.applyPlaceholders(workingTemplate, values);
                return populated.trim();
        }

        sanitizeFilename(text) {
                if (!text || text.trim().length === 0) {
                        return 'Untitled';
                }
		
		// Remove HTML tags
		let filename = text.replace(/<[^>]*>/g, '');
		
		// Replace invalid characters for filenames
		filename = filename.replace(/[<>:"/\\|?*\x00-\x1f]/g, '');
		
		// Replace multiple spaces with single space and trim
		filename = filename.replace(/\s+/g, ' ').trim();
		
		// Limit length to 100 characters
		if (filename.length > 100) {
			filename = filename.substring(0, 100).trim();
		}
		
		// If empty after sanitization, use default name
		if (filename.length === 0) {
			return 'Untitled';
		}
		
		return filename;
	}

        getNormalizedNoteDirectory() {
                const configuredDirectory = (typeof this.settings.noteDirectory === 'string')
                        ? this.settings.noteDirectory.trim()
                        : '';
                const fallbackDirectory = configuredDirectory.length > 0 ? configuredDirectory : 'Explanations';
                const normalized = fallbackDirectory
                        .replace(/\\/g, '/')
                        .replace(/\/{2,}/g, '/')
                        .replace(/\/+$/, '');
                return normalized.length > 0 ? normalized : fallbackDirectory;
        }

        findExistingNotePath(noteDirectory, fileName) {
                if (!noteDirectory || typeof noteDirectory !== 'string') {
                        return null;
                }

                const directoryPrefix = `${noteDirectory}/`;
                const targetLower = fileName.toLowerCase();
                let numericSuffixMatch = null;
                let numericSuffixValue = Number.POSITIVE_INFINITY;

                const files = this.app.vault.getFiles();
                for (const file of files) {
                        if (!file.path.startsWith(directoryPrefix)) {
                                continue;
                        }

                        const relativePath = file.path.substring(directoryPrefix.length);
                        if (relativePath.includes('/')) {
                                continue;
                        }

                        const lowerRelative = relativePath.toLowerCase();
                        if (!lowerRelative.endsWith('.md')) {
                                continue;
                        }

                        const baseName = relativePath.substring(0, relativePath.length - 3);
                        const baseLower = baseName.toLowerCase();

                        if (baseLower === targetLower) {
                                return file.path;
                        }

                        if (!baseLower.startsWith(`${targetLower}-`)) {
                                continue;
                        }

                        const suffix = baseLower.substring(targetLower.length + 1);
                        if (!/^\d+$/.test(suffix)) {
                                continue;
                        }

                        const numericSuffix = parseInt(suffix, 10);
                        if (numericSuffix < numericSuffixValue) {
                                numericSuffixMatch = file.path;
                                numericSuffixValue = numericSuffix;
                        }
                }

                return numericSuffixMatch;
        }

        async createNoteFromExplanation() {
                try {
                        const fileName = this.sanitizeFilename(this.selectionData.selectedText);
                        const noteDirectory = this.getNormalizedNoteDirectory();

                        // Reuse existing note when available
                        const existingNotePath = this.findExistingNotePath(noteDirectory, fileName);
                        if (existingNotePath) {
                                return { notePath: existingNotePath, createdNew: false };
                        }

                        // Create directory if it doesn't exist
                        const adapter = this.app.vault.adapter;
                        if (!(await adapter.exists(noteDirectory))) {
                                await adapter.mkdir(noteDirectory);
                        }

                        // Generate unique filename
                        let notePath = `${noteDirectory}/${fileName}.md`;
                        let counter = 1;

                        while (await adapter.exists(notePath)) {
                                notePath = `${noteDirectory}/${fileName}-${counter}.md`;
                                counter++;
                        }

                        const templateValues = this.buildTemplateValues();
                        const frontMatter = this.buildFrontMatter(this.noteProperties, templateValues);
                        let body = this.buildNoteBody(this.noteBodyTemplate, templateValues);
                        if (!body || body.trim().length === 0) {
                                body = templateValues['{{content}}'] || '';
                        }

                        const sections = [];
                        if (frontMatter) {
                                sections.push(frontMatter);
                        }
                        if (body) {
                                sections.push(body);
                        }

                        const noteContent = sections.join('\n\n');

                        await this.app.vault.create(notePath, noteContent);

                        return { notePath, createdNew: true };
                } catch (error) {
                        console.error('Error creating note:', error);
                        throw error;
                }
        }

	getLinkTextFromNotePath(notePath) {
		const fileName = notePath.split('/').pop().replace('.md', '');
		return `[[${fileName}]]`;
	}

	replaceSelectionWithLink(notePath) {
		const editor = this.selectionData.editor;
		if (!editor) {
			console.warn('Editor not available - skipping text replacement');
			return false;
		}

		const linkText = this.getLinkTextFromNotePath(notePath);
		
		try {
			const selection = editor.getSelection();
			if (selection && selection === this.selectionData.selectedText) {
				editor.replaceSelection(linkText);
				return true;
			}

			const cursor = editor.getCursor();
			const currentLine = editor.getLine(cursor.line);
			const textIndex = currentLine.indexOf(this.selectionData.selectedText);
			if (textIndex !== -1) {
				const lineNumber = cursor.line;
				const from = { line: lineNumber, ch: textIndex };
				const to = { line: lineNumber, ch: textIndex + this.selectionData.selectedText.length };
				editor.replaceRange(linkText, from, to);
				return true;
			}

			editor.replaceSelection(linkText);
			return true;
		} catch (error) {
			console.error('Error replacing selection with link:', error);
			editor.replaceSelection(linkText);
			return true;
		}
	}

	findSelectionIndexInContent(content, selectedText, textBefore, textAfter, paragraphText) {
		if (!selectedText) {
			return -1;
		}

                const matchesContext = (candidateIndex) => {
                        const beforeSlice = content.substring(0, candidateIndex).trimEnd();
                        const afterSlice = content.substring(candidateIndex + selectedText.length).trimStart();
                        const beforeMatch = !textBefore || beforeSlice.endsWith(textBefore);
                        const afterMatch = !textAfter || afterSlice.startsWith(textAfter);
                        return beforeMatch && afterMatch;
                };

		let candidateIndex = content.indexOf(selectedText);
		if (candidateIndex === -1) {
			return -1;
		}

		let index = candidateIndex;
		while (index !== -1) {
			if (matchesContext(index)) {
				return index;
			}
			index = content.indexOf(selectedText, index + 1);
		}

		if (paragraphText) {
			const paragraphIndex = content.indexOf(paragraphText);
			if (paragraphIndex !== -1) {
				const innerIndex = paragraphText.indexOf(selectedText);
				if (innerIndex !== -1) {
					return paragraphIndex + innerIndex;
				}
			}
		}

		return candidateIndex;
	}

	async insertLinkIntoActiveFile(notePath) {
		try {
			const activeFile = this.plugin.app.workspace.getActiveFile();
			if (!activeFile) {
				console.warn('Active file not found - skipping link insertion');
				return false;
			}

			const content = await this.plugin.app.vault.read(activeFile);
			const index = this.findSelectionIndexInContent(
				content,
				this.selectionData.selectedText,
				this.selectionData.textBefore,
				this.selectionData.textAfter,
				this.selectionData.paragraphText
			);

			if (index === -1) {
				console.warn('Selected text not found in active file - skipping link insertion');
				return false;
			}

			const linkText = this.getLinkTextFromNotePath(notePath);
			const updatedContent = `${content.slice(0, index)}${linkText}${content.slice(index + this.selectionData.selectedText.length)}`;
			await this.plugin.app.vault.modify(activeFile, updatedContent);
			return true;
		} catch (error) {
			console.error('Error inserting link into active file:', error);
			return false;
		}
	}

        async createNoteAndLink() {
                try {
                        // Show loading state on button
                        if (this.createNoteButton) {
                                this.createNoteButton.disabled = true;
                        }

                        if (this.audioPromise) {
                                if (this.createNoteButton) {
                                        this.createNoteButton.textContent = 'Waiting for Audio...';
                                }
                                await this.audioPromise;
                        }

                        if (this.createNoteButton) {
                                this.createNoteButton.textContent = 'Creating Note...';
                        }

                        // Create the note
                        const { notePath, createdNew } = await this.createNoteFromExplanation();

                        const normalizedProperties = this.noteProperties
                                .map((property) => ({
                                        key: typeof property.key === 'string' ? property.key.trim() : '',
                                        value: typeof property.value === 'string' ? property.value : ''
                                }))
                                .filter((property) => property.key.length > 0 || property.value.length > 0);

                        this.plugin.settings.noteProperties = normalizedProperties;
                        this.plugin.settings.noteBodyTemplate = this.noteBodyTemplate;
                        await this.plugin.saveSettings();

                        const linkInserted = this.selectionData.editor
                                ? this.replaceSelectionWithLink(notePath)
                                : await this.insertLinkIntoActiveFile(notePath);

                        const message = (() => {
                                if (createdNew) {
                                        return linkInserted
                                                ? `Note created and linked: ${notePath}`
                                                : `Note created (link not inserted automatically): ${notePath}`;
                                }

                                return linkInserted
                                        ? `Existing note linked: ${notePath}`
                                        : `Existing note found (link not inserted automatically): ${notePath}`;
                        })();
			new Notice(message);
			
                        // Close the modal
                        this.close();

                } catch (error) {
                        console.error('Error creating note:', error);
                        new Notice(`Error: ${error.message}`);

                        // Reset button state
                        if (this.createNoteButton) {
                                this.createNoteButton.textContent = 'Create Note & Link';
                                this.createNoteButton.disabled = false;
                        }
                }
        }

        onClose() {
                const { contentEl } = this;
                contentEl.empty();
                this.createNoteButton = null;
                this.audioContainer = null;
                this.audioPromise = null;
                this.audioUrl = '';
                this.audioHtml = '';
        }
}

// Settings tab
class TextExplainerSettingTab extends PluginSettingTab {
	constructor(app, plugin) {
		super(app, plugin);
		this.plugin = plugin;
	}

        display() {
                const { containerEl } = this;
                containerEl.empty();
                containerEl.addClass('text-explainer-settings');

                const storedProperties = Array.isArray(this.plugin.settings.noteProperties)
                        ? this.plugin.settings.noteProperties
                        : [];

                this.noteProperties = (storedProperties.length > 0 ? storedProperties : DEFAULT_NOTE_PROPERTIES)
                        .map((prop) => ({
                                key: (prop && typeof prop.key === 'string') ? prop.key : '',
                                value: (prop && typeof prop.value === 'string') ? prop.value : ''
                        }));

                this.noteBodyTemplate = (typeof this.plugin.settings.noteBodyTemplate === 'string'
                        && this.plugin.settings.noteBodyTemplate.trim().length > 0)
                        ? this.plugin.settings.noteBodyTemplate
                        : DEFAULT_NOTE_BODY_TEMPLATE;

                this.noteSettingsContainer = null;

                containerEl.createEl('h2', { text: 'Text Explainer Settings' });

                // API Key setting
                new Setting(containerEl)
			.setName('API Key')
			.setDesc('Your OpenAI API key or OpenAI-compatible API key')
			.addText(text => text
				.setPlaceholder('sk-...')
				.setValue(this.plugin.settings.apiKey)
				.onChange(async (value) => {
					this.plugin.settings.apiKey = value;
					await this.plugin.saveSettings();
				}));

                // Model setting
                new Setting(containerEl)
                        .setName('Model')
                        .setDesc('LLM model to use')
                        .addText(text => text
                                .setPlaceholder('gpt-3.5-turbo')
                                .setValue(this.plugin.settings.model)
                                .onChange(async (value) => {
                                        this.plugin.settings.model = value;
                                        await this.plugin.saveSettings();
                                }));

                // TTS model setting
                new Setting(containerEl)
                        .setName('TTS Model (optional)')
                        .setDesc('Provide an OpenAI-compatible chat model that returns an MP3 URL to generate audio alongside explanations.')
                        .addText(text => text
                                .setPlaceholder('e.g. Unreal-Speech-TTS')
                                .setValue(this.plugin.settings.ttsModel || '')
                                .onChange(async (value) => {
                                        this.plugin.settings.ttsModel = value.trim();
                                        await this.plugin.saveSettings();
                                }));

                // Language setting
                new Setting(containerEl)
                        .setName('Response Language')
                        .setDesc('Language for explanations and translations')
			.addDropdown(dropdown => dropdown
				.addOption('Chinese', 'Chinese')
				.addOption('English', 'English')
				.addOption('Spanish', 'Spanish')
				.addOption('French', 'French')
				.addOption('German', 'German')
				.addOption('Japanese', 'Japanese')
				.setValue(this.plugin.settings.language)
				.onChange(async (value) => {
					this.plugin.settings.language = value;
					await this.plugin.saveSettings();
				}));

		// Base URL setting
		new Setting(containerEl)
			.setName('Base URL')
			.setDesc('API base URL')
			.addText(text => text
				.setPlaceholder('https://api.openai.com/v1')
				.setValue(this.plugin.settings.baseUrl)
				.onChange(async (value) => {
					this.plugin.settings.baseUrl = value;
					await this.plugin.saveSettings();
				}));

                // Note directory setting
                new Setting(containerEl)
                        .setName('Note Directory')
                        .setDesc('Directory where explanation notes will be created (relative to vault root)')
                        .addText(text => text
                                .setPlaceholder('Explanations')
                                .setValue(this.plugin.settings.noteDirectory)
                                .onChange(async (value) => {
                                        this.plugin.settings.noteDirectory = value;
                                        await this.plugin.saveSettings();
                                }));

                containerEl.createEl('h3', { text: 'Prompt Template' });
                const promptSettingsContainer = containerEl.createDiv('prompt-template-settings');
                promptSettingsContainer.createEl('p', {
                        text: 'Customize the base prompt that is sent to the language model when explaining short selections. '
                                + 'Placeholders are replaced before the request is sent.'
                });

                const promptPlaceholderInfo = promptSettingsContainer.createDiv('placeholder-info');
                promptPlaceholderInfo.createSpan({ text: 'Available placeholders:' });
                const promptPlaceholderList = promptPlaceholderInfo.createEl('ul');
                PROMPT_PLACEHOLDERS.forEach((placeholder) => {
                        const listItem = promptPlaceholderList.createEl('li');
                        listItem.createEl('code', { text: placeholder.token });
                        listItem.createSpan({ text: ` - ${placeholder.description}` });
                });

                const promptTemplateSetting = new Setting(promptSettingsContainer)
                        .setName('Default prompt template')
                        .setDesc('Used when generating explanations for individual words or short phrases.');

                promptTemplateSetting.controlEl.addClass('prompt-template-control');
                const promptTextarea = promptTemplateSetting.controlEl.createEl('textarea', {
                        cls: 'prompt-template-input',
                        attr: { rows: 12 }
                });
                promptTextarea.value = (typeof this.plugin.settings.promptTemplate === 'string'
                        && this.plugin.settings.promptTemplate.length > 0)
                        ? this.plugin.settings.promptTemplate
                        : DEFAULT_PROMPT_TEMPLATE;
                promptTextarea.addEventListener('input', async () => {
                        this.plugin.settings.promptTemplate = promptTextarea.value;
                        await this.plugin.saveSettings();
                });

                containerEl.createEl('h3', { text: 'Default Note Configuration' });
                containerEl.createEl('p', {
                        text: 'Preconfigure the YAML properties and body template that new explanation notes start with. You can still tweak them in the popup before saving.'
                });

                this.noteSettingsContainer = containerEl.createDiv('note-configuration');
                this.noteSettingsContainer.addClass('note-settings-configuration');
                this.renderNoteConfigurationSettings();

                // Hotkey settings section
                containerEl.createEl('h3', { text: 'Hotkey Settings' });

		// Hotkey modifiers
		new Setting(containerEl)
			.setName('Hotkey Modifiers')
			.setDesc('Choose modifier keys (hold Ctrl/Cmd to select multiple)')
			.addDropdown(dropdown => {
				dropdown.addOption('Alt', 'Alt only');
				dropdown.addOption('Ctrl', 'Ctrl only');
				dropdown.addOption('Meta', 'Cmd/Win only');
				dropdown.addOption('Shift', 'Shift only');
				dropdown.addOption('Alt,Shift', 'Alt + Shift');
				dropdown.addOption('Ctrl,Shift', 'Ctrl + Shift');
				dropdown.addOption('Meta,Shift', 'Cmd/Win + Shift');
				const currentModifiers = this.plugin.settings.hotkeyModifiers.join(',');
				dropdown.setValue(currentModifiers);
				dropdown.onChange(async (value) => {
					this.plugin.settings.hotkeyModifiers = value.split(',');
					await this.plugin.saveSettings();
					// Re-register the hotkey command
					this.plugin.app.commands.removeCommand('text-explainer:explain-text-hotkey');
					this.plugin.addCommand({
						id: 'explain-text-hotkey',
						name: 'Explain text (hotkey)',
						hotkeys: [{
							modifiers: this.plugin.settings.hotkeyModifiers,
							key: this.plugin.settings.hotkeyKey
						}],
						checkCallback: (checking) => {
							const selectionData = this.plugin.getSelectedText();
							if (selectionData && selectionData.selectedText) {
								if (!checking) this.plugin.explainSelectedText(selectionData.editor);
								return true;
							}
							return false;
						}
					});
				});
			});

		// Hotkey key
		new Setting(containerEl)
			.setName('Hotkey Key')
			.setDesc('The key to press with the modifiers')
			.addText(text => text
				.setPlaceholder('d')
				.setValue(this.plugin.settings.hotkeyKey)
                                .onChange(async (value) => {
                                        if (value.length === 1) {
                                                this.plugin.settings.hotkeyKey = value.toLowerCase();
                                                await this.plugin.saveSettings();
                                                // Re-register the hotkey command
                                                this.plugin.app.commands.removeCommand('text-explainer:explain-text-hotkey');
                                                this.plugin.addCommand({
                                                        id: 'explain-text-hotkey',
                                                        name: 'Explain text (hotkey)',
                                                        hotkeys: [{
                                                                modifiers: this.plugin.settings.hotkeyModifiers,
                                                                key: this.plugin.settings.hotkeyKey
                                                        }],
                                                        checkCallback: (checking) => {
                                                                const selectionData = this.plugin.getSelectedText();
                                                                if (selectionData && selectionData.selectedText) {
                                                                        if (!checking) this.plugin.explainSelectedText(selectionData.editor);
                                                                        return true;
                                                                }
                                                                return false;
                                                        }
                                                });
                                        }
                                }));
        }

        renderNoteConfigurationSettings() {
                if (!this.noteSettingsContainer) {
                        return;
                }

                this.noteSettingsContainer.empty();

                if (!Array.isArray(this.noteProperties)) {
                        this.noteProperties = [];
                }

                if (this.noteProperties.length === 0) {
                        this.noteProperties.push({ key: '', value: '' });
                }

                this.noteSettingsContainer.createEl('h4', { text: 'Predefined properties' });

                const placeholderInfo = this.noteSettingsContainer.createDiv('placeholder-info');
                placeholderInfo.createSpan({ text: 'Available placeholders:' });
                const placeholderList = placeholderInfo.createEl('ul');
                NOTE_PLACEHOLDERS.forEach((placeholder) => {
                        const listItem = placeholderList.createEl('li');
                        listItem.createEl('code', { text: placeholder.token });
                        listItem.createSpan({ text: ` - ${placeholder.description}` });
                });

                const propertiesTable = this.noteSettingsContainer.createEl('table', { cls: 'note-config-table' });
                const tableHead = propertiesTable.createEl('thead');
                const headRow = tableHead.createEl('tr');
                headRow.createEl('th', { text: 'Property' });
                headRow.createEl('th', { text: 'Value or placeholder' });
                headRow.createEl('th', { text: '' });

                const tableBody = propertiesTable.createEl('tbody');

                this.noteProperties.forEach((property, index) => {
                        const row = tableBody.createEl('tr');

                        const keyCell = row.createEl('td');
                        const keyInput = keyCell.createEl('input', {
                                attr: {
                                        type: 'text',
                                        value: property.key || '',
                                        placeholder: 'Property key'
                                }
                        });
                        keyInput.addEventListener('input', () => {
                                this.noteProperties[index].key = keyInput.value;
                                this.persistNoteConfigurationSettings();
                        });

                        const valueCell = row.createEl('td');
                        const valueWrapper = valueCell.createDiv('value-input-wrapper');
                        const valueInput = valueWrapper.createEl('input', {
                                attr: {
                                        type: 'text',
                                        value: property.value || '',
                                        placeholder: 'Value or choose a placeholder'
                                }
                        });
                        valueInput.addEventListener('input', () => {
                                this.noteProperties[index].value = valueInput.value;
                                this.persistNoteConfigurationSettings();
                        });

                        const placeholderSelect = valueWrapper.createEl('select', { cls: 'placeholder-select' });
                        placeholderSelect.createEl('option', { value: '', text: 'Insert placeholder...' });
                        NOTE_PLACEHOLDERS.forEach((placeholder) => {
                                const option = placeholderSelect.createEl('option', {
                                        value: placeholder.token,
                                        text: placeholder.token
                                });
                                option.setAttr('data-description', placeholder.description);
                                option.setAttr('title', placeholder.description);
                        });
                        placeholderSelect.addEventListener('change', (event) => {
                                const selectValue = event.target.value;
                                if (selectValue) {
                                        valueInput.value = selectValue;
                                        this.noteProperties[index].value = selectValue;
                                        this.persistNoteConfigurationSettings();
                                        event.target.value = '';
                                }
                        });

                        const removeCell = row.createEl('td', { cls: 'note-config-actions' });
                        const removeButton = removeCell.createEl('button', {
                                text: 'Remove',
                                cls: 'note-config-remove'
                        });
                        removeButton.addEventListener('click', (event) => {
                                event.preventDefault();
                                this.noteProperties.splice(index, 1);
                                this.renderNoteConfigurationSettings();
                                this.persistNoteConfigurationSettings();
                        });
                });

                const addRowButton = this.noteSettingsContainer.createEl('button', {
                        text: 'Add property',
                        cls: 'note-config-add-row'
                });
                addRowButton.addEventListener('click', (event) => {
                        event.preventDefault();
                        this.noteProperties.push({ key: '', value: '' });
                        this.renderNoteConfigurationSettings();
                });

                const templateSection = this.noteSettingsContainer.createDiv('note-template-section');
                const templateLabel = templateSection.createEl('label', {
                        attr: { for: 'default-note-template-input' },
                        text: 'Note body template'
                });
                templateLabel.createSpan({ text: ' (include {{content}} where the explanation should appear)' });
                const templateTextarea = templateSection.createEl('textarea', {
                        cls: 'note-template-input',
                        attr: { id: 'default-note-template-input' }
                });
                templateTextarea.value = this.noteBodyTemplate || '';
                templateTextarea.addEventListener('input', () => {
                        this.noteBodyTemplate = templateTextarea.value;
                        this.persistNoteConfigurationSettings();
                });
        }

        async persistNoteConfigurationSettings() {
                if (!this.plugin || !this.plugin.settings) {
                        return;
                }

                const normalizedProperties = Array.isArray(this.noteProperties)
                        ? this.noteProperties
                                .map((property) => ({
                                        key: typeof property.key === 'string' ? property.key.trim() : '',
                                        value: typeof property.value === 'string' ? property.value : ''
                                }))
                                .filter((property) => property.key.length > 0 || property.value.length > 0)
                        : [];

                this.plugin.settings.noteProperties = normalizedProperties.map((property) => ({ ...property }));
                this.plugin.settings.noteBodyTemplate = typeof this.noteBodyTemplate === 'string'
                        ? this.noteBodyTemplate
                        : '';

                await this.plugin.saveSettings();
        }
}

module.exports = TextExplainerPlugin;
